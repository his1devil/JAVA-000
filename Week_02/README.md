
##### 对于STW & SafePoint
由于 GC 过程中需要考虑一致性的问题, 防止因为对象关系的变动, 在进行可达性分析时存在漏判或误判, JVM 在 GC 进行的过程中暂停 Java 所有的执行线程。称为 Stop the world。
如果要触发一次 GC, 那么 JVM 中所有的 Java 线程都必须到达 GC safe point。JVM 只会在特定的位置放置 safe point, 譬如：
内存分配的地方
长时间执行区块结束的时刻(方法调用，循环跳转等)

safe point 还需要考虑一个问题, 如何让线程在 safe point 的位置挂起? 在设计上有两种方案:
抢占式: GC 先把所有线程全部中断, 如果发现有不存在安全点的, 恢复线程, 直至它到达安全点。现在没有虚拟机这么做了。
主动式: GC 为所有线程设置中断标记, 线程在"合适的时候"(通常就是Safe point)去轮询标记, 发现为真时就自动挂起自己。

假如线程一直得不到 cpu 资源, 由于饥饿无法到达safe point, 改如何处理？
JVM 定义了 Safe Region (安全区域)的概念, 扩展了 safe point。线程进入 Safe Region, 表示 GC 可以随时对该线程进行 GC 操作。当线程要离开 Safe Region 时, 会先查看系统是否完成了根节点枚举, 没有的话就等待其完成再离开。

思考: Stop the world其实不一定真的是需要严格挂起所有的用户线程，有些用户线程假如在安全区域里, 可能还能活动一下。


##### 不同收集器的对比
1. Serial/Serial Old 收集器
最基本，最简单的收集器。单线程，主要工作原理，在 JVM 需要 GC 时，暂停所有的工作线程，对新生代进行复制 GC 清除，对老年代进行 标记-整理 清除。
优点: 简单高效，适合单核CPU, Client 模式下的程序
缺点: Stop the world明显, 不适合服务器使用。

2. ParNew 收集器
Serial 收集器的多线程版本, 暂时没有很创新的地方, 但是可以与 CMS 收集器共同协作;
优点: 在多 CPU 的环境下会比 Serial 收集器强;

3. Parallel Scavenge 收集器
这个收集器的目标, 是达到一个可控制的吞吐量。所谓吞吐量，就是 CPU 运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码的时间/(运行用户代码时间 + 垃圾收集器时间)，eg: 虚拟机一共运行100分钟，其中垃圾收集划掉1分钟，那吞吐量就是99%
控制吞吐量大小的两个参数:
XX:MaxGCPauseMilis gc暂停最长时间。时间越短，吞吐量越小
XX:GCTimeRatio 直接设置吞吐量

4 Parallel Old 收集器
Parallel Scavenge 收集器的老年代版本。Parallel Scavenge 收集器是一个优秀的年轻代收集器，但只能与Serial Old合作，于是有了 Parallel Old 与其对接。其组合就是一个吞吐量优先的配置组合，适合一些 CPU 资源比较敏感的应用。
CMS 收集器
Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目标的收集器。关注服务端的响应速度，希望系统停顿时间短，CMS 收集器会非常符合这类应用。过程分4个步骤
初始标记(CMS inital mark)
并发标记(CMS concurrent mark)
重新标记(CMS remark)
并发清除(CMS concurrent sweep)
以下有几个特点：
初始标记、重新标记都是需要Stop the world，不过时间都比较短。
并发标记和并发清除是消耗时间最长的，并且会和用户线程一起进行。
并发标记就是从 CG Root 进行 Tracing 的过程，重新标记阶段是为了修正并发标记期间，用户程序继续运作导致标记产生变动的那一部分对象的标记记录。
优点：
正在的 GC 线程和用户线程共同执行，Stop the world 比较低。
缺点：
CPU 资源敏感，会占用一部分的CPU资源导致用户线程停顿，总吞吐量会下降。一般比较适合多核CPU主机。
无法处理浮动垃圾。由于 CMS 并发清理，所以用户那个阶段产生的对象会无法在当前GC中清除，只能留到下一次GC再清理。那就是需要预留足够的内存空间给用户线程使用，所以CMS线程不能像其他收集器，等待年老代满了再进行收集，要预留空间提供并发收集时的程序使用。-XX:CMSInitiatingOccupancyFraction=70 这个参数是用于控制比率的，老年代的空间达到70%时，激活CMS GC。但假如设置太高，则会导致 Concurrent Mode Failure，GC 会采用后备方案，使用 Serial Old进行。
由于采取标记-清除算法，会存在空间碎片，可能需要引起 Full GC进行解决。


5. G1 收集器
G1 会把一整块的堆空间，划分为固定内存的 region，大小从1-32Mb不等。
region 会被分为 Eden、Survivor和old，这只是一个标签。对 region 的回收是并行的，其他线程照常工作。
Young GC
存活的对象从eden被转移到一个或多个survivor区，年龄达到一定阈值，就上升到 old 区
老年代GC

初始标记 (STW，原理和CMS的基本一致)
根分区扫描
并发标记(在这个堆中查找存活对象。这个阶段可能被YGC打断)
重新标记(STW，完成堆内存中存活对象的标记，使用一种SATB起始快照的算法)
清理阶段。

G1特点
并行和并发
分代收集
空间整合(标记-整理算法)
可预测的停顿(允许程序通过参数约定垃圾收集的时间)

G1适合场景:
和CMS同理，对响应时间要求高，吞吐量要求不太严格的
多核CPU，大内存JVM应用;

|  收集器   | 串行、并行or并发  | 新生代 or 老年代 | 算法 | 目标 | 适用场景 |
|  ----  | ----  |----  |----  |----  |----  |
| Serial  | 串行 |新生代 |复制算法 |响应速度优先 |单CPU环境下的Client模式 |
| Serial Old  | 串行 |老年代 |标记-整理 |响应速度优先 |单CPU环境下的Client模式、CMS的后备预案 |
| ParNew  | 并行 |新生代 |复制算法 |响应速度优先 |多CPU环境时在Server模式下与CMS配合 |
| Parallel Scavenge  | 并行 |新生代 |复制算法 |吞吐量优先 |在后台运算而不需要太多交互的任务 |
| Parallel Old  | 并行 |老年代 |标记-整理 |吞吐量优先 |在后台运算而不需要太多交互的任务 |
| CMS  | 并发 |老年代 |标记-清除 |响应速度优先 |集中在互联网站或B/S系统服务端上的Java应用 |
| G1  | 并发 |both |标记-整理+复制算法 |响应速度优先 |面向服务端应用，将来替换CMS |
